<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <title>Mini Agar Game</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: system-ui, Arial;
      background: #0f1115;
      color: #eee;
    }

    #hud {
      position: fixed;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      backdrop-filter: blur(6px);
    }

    #leaderboard {
      margin-top: 6px;
      font-size: 13px;
    }

    canvas {
      display: block;
    }

    #msg {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, .6);
      padding: 20px 28px;
      border-radius: 12px;
      text-align: center;
      display: none;
    }

    #nameOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #0f1115ee;
      z-index: 50;
    }

    #nameOverlay form {
      background: #161b22;
      padding: 28px 34px;
      border-radius: 14px;
      box-shadow: 0 4px 18px -4px #000;
      min-width: 300px;
    }

    #nameOverlay h1 {
      margin: 0 0 14px;
      font-size: 22px;
    }

    #nameOverlay input {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #333;
      background: #0d1117;
      color: #eee;
      border-radius: 6px;
      font-size: 15px;
    }

    #nameOverlay button {
      margin-top: 14px;
      width: 100%;
      padding: 10px 12px;
      border: none;
      background: #2563eb;
      color: #fff;
      font-weight: 600;
      border-radius: 6px;
      cursor: pointer;
    }

    #nameOverlay button:hover {
      background: #1d4ed8;
    }

    #status {
      position: fixed;
      top: 8px;
      right: 8px;
      background: rgba(0, 0, 0, 0.4);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 13px;
      text-align: right;
    }
  </style>
</head>

<body>
  <div id="nameOverlay">
    <form id="nameForm">
      <h1>Nh·∫≠p t√™n</h1>
      <input id="playerName" maxlength="16" placeholder="T√™n c·ªßa b·∫°n" autocomplete="off" required />
      <button type="submit">B·∫Øt ƒë·∫ßu</button>
    </form>
  </div>
  <div id="hud">
    <div>ID: <span id="pid"></span></div>
    <div>K√≠ch th∆∞·ªõc: <span id="size">0</span></div>
    <div id="leaderboard"></div>
  </div>
  <div id="msg"></div>
  <div id="status"></div>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let W = window.innerWidth,
      H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
    window.addEventListener('resize', () => {
      W = innerWidth;
      H = innerHeight;
      canvas.width = W;
      canvas.height = H;
    });

    const state = {
      id: null,
      players: [],
      foods: [],
      arrows: [],  // th√™m arrays ƒë·ªÉ l∆∞u m≈©i t√™n
      orbitals: [],  // th√™m arrays ƒë·ªÉ l∆∞u v√≤ng tr√≤n quay
      map: {
        w: 3000,
        h: 3000
      }
    };
    let my = null;
    let hasSentName = false;
    let isBoostHeld = false;  // tr·∫°ng th√°i gi·ªØ chu·ªôt tr√°i ƒë·ªÉ boost
    let shieldAmmo = 0;  // s·ªë m≈©i t√™n hi·ªán c√≥
    let deflectShields = 0;  // s·ªë khi√™n ph·∫£n ƒë·∫°n
    let shieldActive = false;  // khi√™n ƒëang ho·∫°t ƒë·ªông
    let shieldCooldown = 0;  // th·ªùi gian cooldown khi√™n
    let invisibilityUntil = 0;  // th·ªùi gian h·∫øt t√†ng h√¨nh

    const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws');

    let speedStacks = 0;
    let speedUntil = 0;
    let shieldUntil = 0;
    let attractUntil = 0;
    let attractRange = 0;

    // Smoothing: l∆∞u v·ªã tr√≠ ƒë√£ l√†m m∆∞·ª£t cho t·ª´ng ng∆∞·ªùi ch∆°i v√† th·ªùi gian khung h√¨nh
    const smoothPlayers = new Map();
    let lastTS = performance.now();
    const BASE_SMOOTHING = 0.25; // 0..1, l·ªõn h∆°n = b√°m s√°t h∆°n (0.2-0.35 l√† h·ª£p l√Ω)

    ws.onmessage = (ev) => {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'init') {
        state.id = msg.id;
        state.map = msg.map;
        document.getElementById('pid').textContent = msg.id;
      } else if (msg.type === 'state') {
        state.players = msg.players;
        state.foods = msg.foods;
        state.arrows = msg.arrows || [];  // c·∫≠p nh·∫≠t danh s√°ch m≈©i t√™n
        state.orbitals = msg.orbitals || [];  // c·∫≠p nh·∫≠t danh s√°ch v√≤ng tr√≤n
        my = state.players.find(p => p.id === state.id);
        if (my) {
          document.getElementById('size').textContent = my.r.toFixed(1);
          shieldAmmo = my.shieldAmmo || 0;  // c·∫≠p nh·∫≠t s·ªë m≈©i t√™n
          deflectShields = my.deflectShields || 0;  // c·∫≠p nh·∫≠t s·ªë khi√™n
          shieldActive = my.shieldActive || false;  // tr·∫°ng th√°i khi√™n
        }
        render();
        updateStatus();
      } else if (msg.type === 'dead') {
        const killerLabel = msg.killerName || (msg.killer ? String(msg.killer).slice(0, 4) : '');
        showMessage('B·∫°n b·ªã ƒÉn b·ªüi ' + killerLabel + '! B·∫°n s·∫Ω h·ªìi sinh.');
        setTimeout(() => hideMessage(), 1500);
      } else if (msg.type === 'effect') {
        if (msg.effect === 'speed') {
          speedStacks = Number(msg.stacks ?? speedStacks) || 0;
          speedUntil = Date.now() / 1000 + (msg.duration ?? 5);
        } else if (msg.effect === 'shield') {
          shieldUntil = Date.now() / 1000 + (msg.duration ?? 5);
          shieldAmmo = msg.ammo || 0;  // c·∫≠p nh·∫≠t s·ªë m≈©i t√™n khi nh·∫≠n shield
        } else if (msg.effect === 'attract') {
          attractRange = Number(msg.range ?? attractRange) || 0;
          attractUntil = Date.now() / 1000 + (msg.duration ?? 10);
        } else if (msg.effect === 'deflect') {
          deflectShields = msg.shields || 0;
        } else if (msg.effect === 'invisibility') {
          invisibilityUntil = Date.now() / 1000 + (msg.duration || 1);
          showMessage(`T√†ng h√¨nh ${msg.duration.toFixed(1)}s!`);
          setTimeout(() => hideMessage(), 1000);
        }
        updateStatus();
      } else if (msg.type === 'shield_result') {
        if (msg.success) {
          shieldActive = true;
          showMessage('Khi√™n ƒë√£ k√≠ch ho·∫°t!');
          setTimeout(() => hideMessage(), 1000);
        } else {
          if (msg.cooldown > 0) {
            showMessage('Khi√™n ƒëang h·ªìi chi√™u!');
          } else {
            showMessage('Kh√¥ng c√≥ khi√™n!');
          }
          setTimeout(() => hideMessage(), 1000);
        }
        deflectShields = msg.shields || 0;
        shieldCooldown = msg.cooldown || 0;
        updateStatus();
      }
    };

    document.getElementById('nameForm').addEventListener('submit', e => {
      e.preventDefault();
      if (hasSentName) return;
      const name = document.getElementById('playerName').value.trim();
      if (name) {
        ws.send(JSON.stringify({
          type: 'set_name',
          name
        }));
        hasSentName = true;
        document.getElementById('nameOverlay').style.display = 'none';
      }
    });

    function showMessage(t) {
      const m = document.getElementById('msg');
      m.textContent = t;
      m.style.display = 'block';
    }

    function hideMessage() {
      document.getElementById('msg').style.display = 'none';
    }

    function updateStatus() {
      const now = Date.now() / 1000;
      const parts = [];
      if (speedUntil > now) {
        const multi = 1 + 0.01 * (Number(speedStacks) || 0);
        const remain = Math.max(0, speedUntil - now).toFixed(1);
        parts.push(`T·ªëc ƒë·ªô x${multi.toFixed(2)} (${remain}s)`);
      }
      if (shieldUntil > now) {
        const remain = Math.max(0, shieldUntil - now).toFixed(1);
        parts.push(`B·∫•t t·ª≠ (${remain}s)`);
      }
      if (attractUntil > now) {
        const remain = Math.max(0, attractUntil - now).toFixed(1);
        parts.push(`L·ª±c h√∫t R=${Math.round(attractRange)} (${remain}s)`);
      }
      if (invisibilityUntil > now) {
        const remain = Math.max(0, invisibilityUntil - now).toFixed(1);
        parts.push(`üëª T√†ng h√¨nh (${remain}s)`);
      }
      if (shieldAmmo > 0) {
        parts.push(`M≈©i t√™n: ${shieldAmmo}`);
      }
      if (deflectShields > 0) {
        parts.push(`Khi√™n: ${deflectShields}`);
      }
      if (shieldActive) {
        parts.push(`üõ°Ô∏è Khi√™n ho·∫°t ƒë·ªông`);
      } else if (shieldCooldown > 0) {
        parts.push(`Khi√™n h·ªìi chi√™u: ${shieldCooldown.toFixed(1)}s`);
      }
      if (isBoostHeld && my && my.r > 10) {
        parts.push(`ƒêang tƒÉng t·ªëc (gi·ªØ chu·ªôt tr√°i)`);
      }
      document.getElementById('status').innerHTML = parts.join('<br>');
    }

    // Track mouse position cho vi·ªác b·∫Øn
    let lastMouseX = 0;
    let lastMouseY = 0;

    canvas.addEventListener('mousemove', e => {
      lastMouseX = e.clientX - canvas.getBoundingClientRect().left;
      lastMouseY = e.clientY - canvas.getBoundingClientRect().top;
      
      if (!my) return;
      const world = screenToWorld(e.clientX, e.clientY);
      ws.send(JSON.stringify({
        type: 'move',
        x: world.x,
        y: world.y
      }));
    });

    // Mouse boost (tƒÉng t·ªëc khi gi·ªØ chu·ªôt tr√°i)
    canvas.addEventListener('mousedown', e => {
      if (e.button === 0 && my && my.r > 10) {  // chu·ªôt tr√°i
        isBoostHeld = true;
        ws.send(JSON.stringify({
          type: 'boost',
          active: true
        }));
        updateStatus();
      }
    });

    canvas.addEventListener('mouseup', e => {
      if (e.button === 0 && isBoostHeld) {  // chu·ªôt tr√°i
        isBoostHeld = false;
        ws.send(JSON.stringify({
          type: 'boost',
          active: false
        }));
        updateStatus();
      }
    });

    // B·∫Øn m≈©i t√™n v·ªõi ph√≠m Space
    document.addEventListener('keydown', e => {
      if (e.code === 'Space' && my && shieldAmmo > 0) {
        e.preventDefault();
        // B·∫Øn v·ªÅ ph√≠a con tr·ªè chu·ªôt
        const world = screenToWorld(lastMouseX, lastMouseY);
        
        ws.send(JSON.stringify({
          type: 'shoot',
          x: world.x,
          y: world.y
        }));
        shieldAmmo = Math.max(0, shieldAmmo - 1);  // gi·∫£m locally ƒë·ªÉ responsive
        updateStatus();
      } else if (e.code === 'KeyZ' && my && deflectShields > 0 && !shieldActive) {
        e.preventDefault();
        // K√≠ch ho·∫°t khi√™n ph·∫£n ƒë·∫°n
        ws.send(JSON.stringify({
          type: 'shield'
        }));
      }
    });
    canvas.addEventListener('touchmove', e => {
      if (!my) return;
      const t = e.touches[0];
      const world = screenToWorld(t.clientX, t.clientY);
      ws.send(JSON.stringify({
        type: 'move',
        x: world.x,
        y: world.y
      }));
      e.preventDefault();
    }, {
      passive: false
    });

    function screenToWorld(sx, sy) {
      if (!my) return {
        x: 0,
        y: 0
      };
      const scale = 1; // Could add zoom based on size
      const camX = my.x - W / 2;
      const camY = my.y - H / 2;
      return {
        x: camX + sx / scale,
        y: camY + sy / scale
      };
    }

    function render() {
      if (!my) {
        ctx.clearRect(0, 0, W, H);
        return;
      }
      ctx.clearRect(0, 0, W, H);

      // T√≠nh h·ªá s·ªë n·ªôi suy theo th·ªùi gian khung h√¨nh (·ªïn ƒë·ªãnh ·ªü 60 FPS)
      const nowTS = performance.now();
      const frames = Math.max(1, (nowTS - lastTS) / 16.6667);
      const alpha = 1 - Math.pow(1 - BASE_SMOOTHING, frames);
      lastTS = nowTS;

      // L√†m m∆∞·ª£t v·ªã tr√≠ c·ªßa b·∫£n th√¢n ƒë·ªÉ camera ƒë·ª° rung
      let myS = smoothPlayers.get(my.id);
      if (!myS) {
        myS = { x: my.x, y: my.y, r: my.r, attractRange: Number(my.attractRange || 0) };
        smoothPlayers.set(my.id, myS);
      } else {
        myS.x += (my.x - myS.x) * alpha;
        myS.y += (my.y - myS.y) * alpha;
        myS.r += (my.r - myS.r) * alpha;
        myS.attractRange += ((Number(my.attractRange || 0)) - myS.attractRange) * alpha;
      }

      const camX = myS.x - W / 2;
      const camY = myS.y - H / 2;

      // Background grid
      ctx.strokeStyle = '#1d2228';
      ctx.lineWidth = 1;
      const gridSize = 100;
      const startX = - (camX % gridSize);
      const startY = - (camY % gridSize);
      for (let x = startX; x < W; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      for (let y = startY; y < H; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
      }

      // Foods
      for (const f of state.foods) {
        const sx = f.x - camX;
        const sy = f.y - camY;
        if (sx < -20 || sx > W + 20 || sy < -20 || sy > H + 20) continue;
        const fr = (typeof f.r === 'number' ? f.r : 6);
        const color = f.color || '#ffd54f';
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(sx, sy, fr, 0, Math.PI * 2);
        ctx.fill();
      }

      // Arrows (m≈©i t√™n)
      for (const arrow of state.arrows) {
        const sx = arrow.x - camX;
        const sy = arrow.y - camY;
        if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) continue;
        
        // V·∫Ω m≈©i t√™n nh∆∞ m·ªôt ƒë∆∞·ªùng th·∫≥ng c√≥ ƒë·∫ßu m≈©i
        const speed = Math.hypot(arrow.vx, arrow.vy);
        const length = 15; // ƒë·ªô d√†i m≈©i t√™n tr√™n m√†n h√¨nh
        const dx = (arrow.vx / speed) * length;
        const dy = (arrow.vy / speed) * length;
        
        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        
        // Th√¢n m≈©i t√™n
        ctx.beginPath();
        ctx.moveTo(sx - dx, sy - dy);
        ctx.lineTo(sx, sy);
        ctx.stroke();
        
        // ƒê·∫ßu m≈©i t√™n
        const arrowSize = 6;
        const angle = Math.atan2(arrow.vy, arrow.vx);
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx - arrowSize * Math.cos(angle - Math.PI/6), sy - arrowSize * Math.sin(angle - Math.PI/6));
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx - arrowSize * Math.cos(angle + Math.PI/6), sy - arrowSize * Math.sin(angle + Math.PI/6));
        ctx.stroke();
      }

      // Orbitals (v√≤ng tr√≤n ph√≤ng th·ªß)
      if (state.orbitals && state.orbitals.length > 0) {
        console.log('Rendering orbitals:', state.orbitals.length);
        for (const orbital of state.orbitals) {
          const sx = orbital.x - camX;
          const sy = orbital.y - camY;
          if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) continue;
          
          // V·∫Ω v√≤ng tr√≤n quay
          ctx.beginPath();
          ctx.fillStyle = '#f97316'; // m√†u cam
          ctx.strokeStyle = '#ff8c42';
          ctx.lineWidth = 2;
          ctx.arc(sx, sy, 8, 0, Math.PI * 2); // k√≠ch th∆∞·ªõc v√≤ng tr√≤n
          ctx.fill();
          ctx.stroke();
          
          // Th√™m hi·ªáu ·ª©ng ph√°t s√°ng
          ctx.save();
          ctx.shadowColor = '#f97316';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(sx, sy, 4, 0, Math.PI * 2);
          ctx.fillStyle = '#ffab66';
          ctx.fill();
          ctx.restore();
        }
      }

      // Players (v·ªã tr√≠ ƒë√£ l√†m m∆∞·ª£t) + v√≤ng l·ª±c h√∫t c√πng m√†u
      const sorted = [...state.players].sort((a, b) => a.r - b.r);
      for (const p of sorted) {
        let s = smoothPlayers.get(p.id);
        if (!s) {
          s = { x: p.x, y: p.y, r: p.r, attractRange: Number(p.attractRange || 0) };
          smoothPlayers.set(p.id, s);
        } else {
          s.x += (p.x - s.x) * alpha;
          s.y += (p.y - s.y) * alpha;
          s.r += (p.r - s.r) * alpha;
          s.attractRange += ((Number(p.attractRange || 0)) - s.attractRange) * alpha;
        }

        const sx = s.x - camX,
          sy = s.y - camY;
        
        // Set alpha for invisible players
        const isInvisible = p.invisible || false;
        if (isInvisible && p.id !== state.id) {
          ctx.globalAlpha = 0.2; // R·∫•t m·ªù cho invisible players (tr·ª´ b·∫£n th√¢n)
        } else if (isInvisible && p.id === state.id) {
          ctx.globalAlpha = 0.6; // H∆°i m·ªù cho b·∫£n th√¢n khi invisible
        } else {
          ctx.globalAlpha = 1.0; // B√¨nh th∆∞·ªùng
        }
        
        // N√∫t ng∆∞·ªùi ch∆°i
        ctx.beginPath();
        ctx.fillStyle = p.color;
        ctx.arc(sx, sy, s.r, 0, Math.PI * 2);
        ctx.fill();

        // T√™n
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText((p.name || p.id.slice(0, 4)), sx, sy + 4);
        if (p.id === state.id) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); }
        
        // Reset alpha
        ctx.globalAlpha = 1.0;

        // Khi√™n ph·∫£n ƒë·∫°n (m√†u h·ªìng khi active)
        if (p.shieldActive) {
          ctx.save();
          ctx.strokeStyle = '#ec4899'; // m√†u h·ªìng
          ctx.globalAlpha = 0.7;
          ctx.lineWidth = 4;
          ctx.setLineDash([8, 4]);
          ctx.beginPath();
          ctx.arc(sx, sy, s.r + 8, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // V√≤ng l·ª±c h√∫t (c√πng m√†u v·ªõi n√∫t), hi·ªÉn th·ªã khi c√≤n ƒë√°ng k·ªÉ
        if (s.attractRange > 0.5) {
          const rr = s.r + s.attractRange;
          ctx.save();
          ctx.strokeStyle = p.color; // c√πng m√†u v·ªõi ng∆∞·ªùi ch∆°i
          ctx.globalAlpha = (p.id === state.id) ? 0.85 : 0.55; // ƒë·∫≠m h∆°n cho b·∫£n th√¢n
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          ctx.beginPath();
          ctx.arc(sx, sy, rr, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
      }

      // Leaderboard & status
      const board = [...state.players].sort((a, b) => b.r - a.r).slice(0, 8)
        .map((p, i) => `#${i + 1} ${(p.name || p.id.slice(0, 4))} ${(p.r).toFixed(1)}`).join('<br>');
      document.getElementById('leaderboard').innerHTML = '<b>B·∫£ng x·∫øp h·∫°ng</b><br>' + board;
      updateStatus();
    }

    // V√≤ng l·∫∑p v·∫Ω ƒë·ªÉ chuy·ªÉn ƒë·ªông m∆∞·ª£t h∆°n (thay v√¨ ch·ªâ render khi c√≥ g√≥i tin)
    (function loop() {
      render();
      requestAnimationFrame(loop);
    })();
  </script>
</body>

</html>